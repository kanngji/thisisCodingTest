복잡도는 알고리즘의 성능을 나타내는 척도이다

복잡도는 시간 복잡도와 공간 복잡도로 나눌수 있다

시간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 오래 걸리는지를 의미하고
공간 복잡도는 특정한 크기의 입력에 대하여 알고리즘이 얼마나 많은 메모리를 차지하는지를 의미한다.

시간 복잡도: 알고리즘을 위해 필요한 연산의 횟수
공간 복잡도: 알고리즘을 위해 필요한 메모리의 양

시간 복잡도를 표현할 때는 빅오 표기법을 사용한다
간단히 정의하자만 가장 빠르게 증가하는 항만을 고려하는 표기법이다

다시 말해 함수의 상한만을 나타낸다

ex)
array = [3,5,1,2,4]
summary = 0

# 모든 데이터를 하나씪 확인하며 합계를 계산
for x in array:
    summary +=x

#결과를 출력
print(summary)

가장 영향력이 큰 부분은 N에 비례하는 연산을 수행하는 반복문 부분이므로 시간복잡도를 O(N)이라고 표기한다

ex)
a= 5
b= 7
print(a+b)

이 소스코드의 연산 횟수는 1이다
시간 복잡도는 O(1)로 표현할수 있다.


ex)
array = [3,5,1,2,4]

for i in array:
    for j in array:
        temp = i * j
        print(temp)

이 소스코드는 데이터의 개수가 N개 일 때, O(N^2)의 시간 복잡도를 가진다
하지만 모든 2중 반복문의 시간 복잡도가 O(N^2)은 아니다. 만약 소스코드가 내부적으로 다른 함수를 호출한다면 
내부 함수의 시간 복잡도까지 고려해야 한다.

일반적으로 문제를 풀 때의 예시를 몇 가지 소개하겠다.
모두 시간 제한이 1초인 문제에 대한 예시이다.

* N의 범위가 500인 경우: 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제를 풀 수 있다
* N의 범위가 2,000인 경우: 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제를 풀 수 있다.
* N의 범위가 100,000인 경우: 시간복잡도가 O(NlogN)인 알고리즘을 설계하면 문제를 풀 수 있다.
* N의 범위가 10,000,000인 경우: 시간복잡도가 O(N)인 알고리즘을 설계하면 문제를 풀 수 있다.

수행 시간 측정 소스코드 

https://replit.com/languages/python3 여기서 쳐서 확인

import time
start_time = time.time()

end_time = time.time()
print("time:", end_time - start_time)

동일한 기능을 수행하는 알고리즘이 2개 각각 a와 b 있을 때 만약 a 알고리즘이 b 보다
시간 복잡도가 더 높다면, a 알고리즘이 실행 시간 측면에서 성능이 더 낮다는 의미이다.




